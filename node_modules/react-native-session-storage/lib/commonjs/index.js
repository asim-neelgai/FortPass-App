"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = exports.Storage = void 0;
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
// Original source: https://stackoverflow.com/a/67368639/7040601

class Storage {
  constructor() {
    _defineProperty(this, "data", void 0);
    this.data = new Map();
  }

  /**
   * Get key name by index
   * @param n index
   * @returns key
   */
  key(n) {
    return [...this.data.keys()][n];
  }

  /**
   * Get value by key
   * @param key
   * @returns value if present else `undefined`
   */
  getItem(key) {
    return this.data.get(key);
  }

  /**
   * Get how many keys-value pairs are stored
   */
  get length() {
    return this.data.size;
  }

  /**
   * Store key-value pair
   * @param key
   * @param value
   */
  setItem(key, value) {
    this.data.set(key, value);
  }

  /**
   * Removes value by key
   * @param key
   */
  removeItem(key) {
    this.data.delete(key);
  }

  /**
   * Clear all keys
   */
  clear() {
    this.data = new Map();
  }
}
exports.Storage = Storage;
const SessionStorage = new Storage();
var _default = SessionStorage;
exports.default = _default;
//# sourceMappingURL=index.js.map